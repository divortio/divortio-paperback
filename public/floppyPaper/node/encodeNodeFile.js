/**
 * @file encodeNodeFile.js
 * @overview
 * Implements the high-level, asynchronous encoding function that drives the entire
 * print pipeline. This function serves as the public API for Node.js environments,
 * handling state initialization, the main execution loop, and final disk I/O.
 *
 * It mirrors the "while (pb_printdata.step != 0)" loop found in the C main.c source.
 */
import * as fs from 'fs';
import * as path from 'path';
import { NodeFile } from '../lib/classes/nodeFile.js';
import { GlobalState } from '../lib/classes/globalState.js';
import { EncoderState } from '../lib/classes/encoderState.js';
import { encodeFile } from '../lib/encodeFile.js';

/**
 * Executes the full encoding pipeline on a local file, converting it into one or more
 * high-density BMP images and writing them to the filesystem.
 * @param {string} inputFilePath - The path to the local file to be encoded.
 * @param {string} outputBmpFilePath - The base path/name for the output BMP file(s) (e.g., './output/backup.bmp').
 * @param {boolean} [enableCompression=false] - Enables Bzip2 compression (maps to C level 2: Maximal).
 * @param {string} [password=''] - Encryption passphrase.
 * @param {number} [dpi=200] - Dots per inch for the raster (C: pb_dpi). Default: 200.
 * @param {number} [dotPercent=70] - Size of dots as a percentage of max dot size (C: pb_dotpercent). Default: 70.
 * @param {number} [redundancy=5] - Data redundancy ratio (e.g., 5 for 1:5 redundancy) (C: pb_redundancy). Default: 5.
 * @param {number} [printHeader=0] - Flag to print file header/footer (1: print, 0: skip) (C: pb_printheader). Default: 0.
 * @param {number} [printBorder=0] - Flag to print a black border around the data grid (C: pb_printborder). Default: 0.
 * @returns {Promise<Array<string>>} A promise resolving to an array of paths to the newly created BMP files.
 */
export async function encodeNodeFile(
    inputFilePath,
    outputBmpFilePath,
    enableCompression = false,
    password = '',
    dpi = 200,
    dotPercent = 70,
    redundancy = 5,
    printHeader = 0,
    printBorder = 0
) {

    // 1. Setup State and Abstraction

    // Determine C compression level (0, 1, or 2). We set it to 2 (Maximal) if enabled.
    const compressionLevel = enableCompression ? 2 : 0;

    // Initialize GlobalState with named arguments.
    const globalState = new GlobalState({
        dpi: dpi,
        dotPercent: dotPercent,
        redundancy: redundancy,
        printHeader: printHeader,
        printBorder: printBorder,
        compression: compressionLevel,
        // Set encryption flag based on whether a password was provided
        encryption: password ? 1 : 0
    });

    const encoderState = new EncoderState();

    // Abstract the local file system path into a File object mock for the pipeline
    const mockInputFile = new NodeFile(inputFilePath);

    // 2. Execute the Core Encoding Pipeline
    const outputFiles = await encodeFile(
        globalState,
        encoderState,
        mockInputFile,
        outputBmpFilePath,
        password
    );

    // 3. Final I/O: Write BMP Buffers to Disk
    const createdPaths = [];

    // Ensure output directory exists (Node.js requirement)
    const directory = path.dirname(outputBmpFilePath);
    if (directory && !fs.existsSync(directory)) {
        fs.mkdirSync(directory, { recursive: true });
    }

    for (const fileData of outputFiles) {
        // Construct the full output path using the file name generated by the pipeline
        const outputPath = path.join(directory, fileData.fileName);

        // Write the binary data (Uint8Array) to disk
        fs.writeFileSync(outputPath, fileData.data);
        createdPaths.push(outputPath);
    }

    return createdPaths;
}